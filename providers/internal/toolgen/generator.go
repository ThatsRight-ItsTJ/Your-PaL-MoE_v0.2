package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"sort"
	"strings"
	"text/template"
)

// Generator generates the tool metadata registry file
type Generator struct{}

// NewGenerator creates a new metadata file generator
func NewGenerator() *Generator {
	return &Generator{}
}

// GenerateMetadataFile generates the Go source file with tool metadata
func (g *Generator) GenerateMetadataFile(metadata []ToolMetadata) (string, error) {
	// Sort tools by name for consistent output
	sort.Slice(metadata, func(i, j int) bool {
		return metadata[i].Name < metadata[j].Name
	})

	tmplText := `// Code generated by toolgen. DO NOT EDIT.

package tools

import (
	"encoding/json"
	"fmt"
	
	"github.com/lexlapax/go-llms/pkg/agent/domain"
)

// ToolManifest provides static tool metadata without requiring imports
var ToolManifest = map[string]ToolInfo{
{{- range .Tools }}
	"{{ .Name }}": {
		Name:        "{{ .Name }}",
		Description: {{ printf "%q" .Description }},
		Category:    "{{ .Category }}",
		Tags:        {{ .Tags | formatStringSlice }},
		Version:     "{{ .Version }}",
		Package:     "{{ .Package }}",
		{{- if .ParameterSchema }}
		ParameterSchema: json.RawMessage(` + "`" + `{{ .ParameterSchema | toJSON }}` + "`" + `),
		{{- end }}
		{{- if .OutputSchema }}
		OutputSchema: json.RawMessage(` + "`" + `{{ .OutputSchema | toJSON }}` + "`" + `),
		{{- end }}
		{{- if .UsageInstructions }}
		UsageHint: {{ printf "%q" .UsageInstructions }},
		{{- end }}
		{{- if .Examples }}
		Examples: []Example{
			{{- range .Examples }}
			{
				Name:        {{ printf "%q" .Name }},
				Description: {{ printf "%q" .Description }},
				{{- if .Input }}
				Input:       json.RawMessage(` + "`" + `{{ .Input | toJSON }}` + "`" + `),
				{{- end }}
				{{- if .Output }}
				Output:      json.RawMessage(` + "`" + `{{ .Output | toJSON }}` + "`" + `),
				{{- end }}
			},
			{{- end }}
		},
		{{- end }}
	},
{{- end }}
}

// toolFactories maps tool names to their factory functions
var toolFactories = map[string]ToolFactory{
{{- range .Tools }}
	"{{ .Name }}": create{{ .Name | toCamelCase }}Factory(),
{{- end }}
}

// Factory creator functions
{{- range .Tools }}

func create{{ .Name | toCamelCase }}Factory() ToolFactory {
	return func() (domain.Tool, error) {
		// Placeholder implementation
		// The actual tool creation will be provided by registry_factories.go
		return nil, fmt.Errorf("tool {{ .Name }} not yet loaded - import the tool package to use it")
	}
}
{{- end }}

func init() {
	// Register all metadata with the discovery system
	for name, info := range ToolManifest {
		factory := toolFactories[name]
		if err := RegisterToolMetadata(info, factory); err != nil {
			panic(fmt.Sprintf("failed to register tool metadata for %s: %v", name, err))
		}
	}
}
`

	// Create template with helper functions
	tmpl, err := template.New("metadata").Funcs(template.FuncMap{
		"formatStringSlice": formatStringSlice,
		"toJSON":            toJSON,
		"toCamelCase":       toCamelCase,
	}).Parse(tmplText)
	if err != nil {
		return "", fmt.Errorf("parsing template: %w", err)
	}

	// Execute template
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, map[string]interface{}{
		"Tools": metadata,
	}); err != nil {
		return "", fmt.Errorf("executing template: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted code for debugging
		return buf.String(), fmt.Errorf("formatting generated code: %w", err)
	}

	return string(formatted), nil
}

// GenerateFactoryFile generates a separate file with actual factory implementations
func (g *Generator) GenerateFactoryFile(metadata []ToolMetadata) (string, error) {
	// Group tools by package
	toolsByPackage := make(map[string][]ToolMetadata)
	for _, tool := range metadata {
		pkg := getPackageAlias(tool.Package)
		toolsByPackage[pkg] = append(toolsByPackage[pkg], tool)
	}

	tmplText := `// Code generated by toolgen. DO NOT EDIT.

// +build tools

package tools

import (
	"github.com/lexlapax/go-llms/pkg/agent/domain"
	{{- range $pkg, $tools := .ToolsByPackage }}
	{{ $pkg }} "{{ (index $tools 0).Package }}"
	{{- end }}
)

// This file provides the actual factory implementations when tools are imported

func init() {
	// Override the placeholder factories with real implementations
	{{- range .Tools }}
	toolFactories["{{ .Name }}"] = func() (domain.Tool, error) {
		return {{ getPackageAlias .Package }}.{{ .ConstructorFunc }}(), nil
	}
	{{- end }}
}
`

	tmpl, err := template.New("factories").Funcs(template.FuncMap{
		"toCamelCase":     toCamelCase,
		"getPackageAlias": getPackageAlias,
	}).Parse(tmplText)
	if err != nil {
		return "", fmt.Errorf("parsing template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, map[string]interface{}{
		"Tools":          metadata,
		"ToolsByPackage": toolsByPackage,
	}); err != nil {
		return "", fmt.Errorf("executing template: %w", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return buf.String(), fmt.Errorf("formatting generated code: %w", err)
	}

	return string(formatted), nil
}

// Helper functions for templates

func formatStringSlice(slice []string) string {
	if len(slice) == 0 {
		return "[]string{}"
	}
	quoted := make([]string, len(slice))
	for i, s := range slice {
		quoted[i] = fmt.Sprintf("%q", s)
	}
	return fmt.Sprintf("[]string{%s}", strings.Join(quoted, ", "))
}

func toJSON(v interface{}) string {
	data, _ := json.Marshal(v)
	return string(data)
}

func toCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

func getPackageAlias(pkgPath string) string {
	parts := strings.Split(pkgPath, "/")
	if len(parts) > 0 {
		return parts[len(parts)-1]
	}
	return "unknown"
}
